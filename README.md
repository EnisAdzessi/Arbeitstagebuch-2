# Arbeitstagebuch 2.Halbjahr
<p>
Stormarnschule 2021 
     
     
Informatik, Bl

Julian Hayer, Enis Adzessi
	

</p>
</br>
</br>


## Stundenübersicht
<table align="center">
  <tr>
    <td><a href="#14.12.2021"> 14.12.2021 </a></td>
    <td><a href="#15.12.2021"> 15.12.2021 </a></td>
    <td><a href="#21.12.2021"> 21.12.2021 </a></td>
    <td><a href="#22.12.2021"> 22.12.2021 </a></td>
</tr>
  <tr>
    <td><a href="#11.1.2022"> 11.1.2022 </a></td>
    <td><a href="#12.1.2022"> 12.1.2022 </a></td>
    <td><a href="#18.1.2022"> 18.1.2022 </a></td>
    <td><a href="#19.1.2022"> 19.1.2022 </a></td>
 </tr>
   <tr>
     <td><a href="#25.1.2022"> 25.1.2022 </a></td>
     <td><a href="#26.1.2022"> 26.1.2022 </a></td>
     <td><a href="#1.2.2022"> 1.2.2022 </a></td>
     <td><A href="#2.2.2022"> 2.2.2022 </a></td>
     
  </tr>
    <tr>
      <td><a href="#8.2.2022"> 8.2.2022 </a></td>
      <td><a href="#9.2.2022"> 9.2.2022 </a></td>
      <td><a href="#15.2.2022"> 15.2.2022 </a></td>
      <td><a href="#16.2.2022"> 16.2.2022 </a></td>
  </tr>
    <tr>
      <td><a href="#22.2.2022"> 22.2.2022 </a></td>
      <td><a href="#23.2.2022"> 23.2.2022 </a></td>
      <td><a href="#1.3.2022"> 1.3.2022 </a></td>
      <td><a href="#2.3.2022"> 2.3.2022 </a></td>
   
   </tr>
    <tr>
      <td><a href="#8.3.2022"> 8.3.2022 </a></td>
      <td><a href="#9.3.2022"> 9.3.2022 </a></td>
      <td><a href="#15.3.2022"> 15.3.2022 </a></td>
      <td><a href="#16.3.2022"> 16.3.2022 </a></td>
   </tr>
    <tr>
      <td><a href="#22.3.2022"> 22.3.2022 </a></td>
      <td><a href="#23.3.2022"> 23.3.2022 </a></td>
      <td><a href="#29.3.2022"> 29.3.2022 </a></td>
      <td><a href="#30.3.2022"> 30.3.2022 </a></td>
  
  <table align="center">
<tr>
	<td> <a href="#Arbeitsprogress in den Ferien"> Arbeitsprogress in den Ferien </a></td>
</tr>
       </table>
 <br>   
      
 ## <p> <h2> <a id="14.12.2021"> 14.12.2021 </a> </h2>
      
In der heutigen Stunde haben wir über verschiedene Projektmöglichkeiten gesprochen, die uns jetzt zur Verfügung stehen. Da das zweite Halbjahr           
    wollten wir die Idee, die wir in der ersten Jahreshälfte hatten, nämlich mit Unity zu programmieren, weiterführen.  
    Da keiner von uns zuvor mit Unity gearbeitet hatte, war die Frage, ob wir mit Blueprints arbeiten wollten. 
    Blueprints. Das hätte den Nachteil, dass wir dafür Geld ausgeben müssten. Außerdem stellten wir während des Unterrichts fest, dass Unity nicht          
    auf den Schulcomputern installiert werden konnte, was es unmöglich machen würde, in der Schule an dem Projekt zu arbeiten.
 
      
## <p> <h2> <a id="15.12.2021"> 15.12.2021 </a> </h2>
      
  Heute haben wir nach Alternativen zu Unity umgeschaut. Als erstes fiel uns Unreal Engine auf, mit der viele Spiele programmiert    
    wurden, die wir unserer Freizeit spielen oder gespielt haben. Hier tritt, allerdings wieder das Problem auf, dass sich die Unreal Engine, 
    wie Unity auch, nicht auf den Schulcomputern runterladen ließ.        
 
 ## <p> <h2> <a id="21.12.2021"> 21.12.2021 </a> </h2>
    
  Heute spielten wir mit der gesamten Klassse Secret Hitler. Wir arbeiteten nicht an unseren Projekten weiter
      
 ## <p> <h2> <a id="22.12.2021"> 22.12.2021 </a> </h2>
      
  *Entfall*
      
 ## <p> <h2> <a id="11.1.2022"> 11.1.2022 </a> </h2>
      
  In dieser Doppelstunde haben wir uns zusammengesetzt und unsere Ideen, die wir in den Ferien entwickelt haben, ausgetauscht. Und wir kamen zu dem Entschluss, dass wir ein Jump'n Run als Spiel programmieren wollen. Wir haben Scratch als Programm für unser Spiel gewählt, weil Scratch für Jump'n Runs besser geeignet ist als andere Blocksprachen wie Snap! Vor allem, weil Scratch die Funktion "run without screen refresh" hat, die für ein sehr flüssiges Spielerlebnis sorgt. Mit dieser Funktion kann ein Befehl ständig überprüft werden, ohne dass jeder andere Befehl zuerst überprüft wird. Dadurch läuft das Spiel sehr schnell und schont die Ressourcen des Computers.
Außerdem diente diese Stunde dazu, unsere Spielidee weiterzuentwickeln und ein genaueres Bild von unserem Endprodukt zu erstellen.

      <br> 
      <details>
	<summary>Run without screen refresh Funktion</summary>
 ![run without screen refresh](https://user-images.githubusercontent.com/88385824/163691571-4d85f686-a2a3-49db-bdf0-0ad96c3da182.PNG)
	
</details>
      
      
## <p> <h2> <a id="12.1.2022"> 12.1.2022 </a> </h2>

Wir haben diese Stunde genutzt, um uns zunächst mit Hilfe verschiedener Quellen einen Einblick in die Thematik der Programmierung von Jump'n Run mit Scratch zu verschaffen. Vor allem die große Scratch-Community diente uns als Quelle, und in Online-Foren gab es sehr hilfreiche Tipps. Außerdem haben wir uns die Codes von bereits existierenden Spielen angesehen, um uns mit verschiedenen Praktiken vertraut zu machen.

     <details>
	     <summary>Forum</summary>
	     <a href="https://scratch.mit.edu/discuss/13/"> Link zu einem Forum </a>

</details>
	    
## <p> <h2> <a id="18.1.2022"> 18.1.2022 </a> </h2>
	    
 In dieser Stunde hatte die Gruppe die Idee, das Spiel auf Snap! zu programmieren, weil diese Plattform einige Funktionen bietet, die in Scratch fehlen. Zum Beispiel die sogenannte Warp-Funktion, die dafür sorgt, dass ein bestimmter Befehl immer geprüft wird, ohne dass andere Befehle zuerst geprüft werden. So wurde diese Stunde genutzt, um den kurzen vorherigen Code zu übertragen und die neuen Funktionen zu testen. Der bisherige Code bestand im Grunde nur aus der einfachen Mechanik für die Spielerbewegung und einer Schwerkraft. Aber dieser sehr kleine Code in Kombination mit der Warp-Funktion war bereits zu leistungsintensiv für die Schulcomputer. Also nutzten wir den Rest der Stunde, um uns über leistungsoptimierende Funktionen zu informieren und diese zu testen.   

## <p> <h2> <a id="19.1.2022"> 19.1.2022 </a> </h2>

In der letzten Stunde haben wir die Plattform gewechselt, aber wir haben gemerkt, dass wir die Schulcomputer schon mit sehr wenig Code überladen haben. Also beschlossen wir, wieder zu Scratch zu wechseln, da Scratch als Plattform grundsätzlich besser optimiert ist und es mehr Funktionen gibt, die eine viel bessere Leistung bieten. Also nutzten wir diese Stunde, um den Code erneut zu übertragen und begannen, ein erstes Hindernis zu integrieren.

## <p> <h2> <a id="25.1.2022"> 25.1.2022 </a> </h2>
	    
*Entfall*
	    

## <p> <h2> <a id="26.1.2022"> 26.1.2022 </a> </h2>
	    
*Entfall*

## <p> <h2> <a id="1.2.2022"> 1.2.2022 </a> </h2>

Diese Stunde wurde genutzt, um grundlegende Spielmechaniken so leistungsoptimiert wie möglich zu gestalten. Denn unser Ziel für unser Spiel ist es, dass es so reibungslos wie möglich läuft und auf möglichst vielen Computern läuft. Also gingen wir in Foren, um uns über weitere Leistungsoptimierungen zu informieren. Wir haben angefangen, eine Menge eigener Blöcke zu erstellen, die das Spiel viel flüssiger laufen lassen. In dieser Lektion haben wir zum Beispiel die Überprüfung, ob sich der Spieler in der Luft oder auf dem Boden befindet, als Block definiert. Außerdem haben wir einen sich bewegenden Block hinzugefügt, für den wir wiederum einen Block erstellt haben, der die Animation der Bewegung steuert. Es trat jedoch das Problem auf, dass sich unser Spieler nach oben teleportierte, wenn er den Block berührte. Wir haben den Rest der Stunde versucht, dieses Problem zu beheben, aber leider ist es uns nicht gelungen. Wir haben diesen Block vorerst aus Level 1 entfernt.
    
<details>
	  <summary>Überprüfung der Boden-Berührung</summary>

![Screenshot github](https://user-images.githubusercontent.com/88385822/163804066-349b1593-a229-446b-ac07-b6f9df3b0a22.PNG)

</details>
<br> 
<details>
	<summary>Bewegender-Block Animation</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163804225-b2fa61a6-bf2d-45ac-9838-856d6b534b15.png)
	
</details>
	    

## <p> <h2> <a id="2.2.2022"> 2.2.2022 </a> </h2>
	    
In der heutigen Unterrichtsstunde haben wir uns hauptsächlich mit Github beschäftigt. Wir haben damit begonnen, unsere Texte in Word vorzuschreiben, sodass wir sie nur noch in das Github-Repository einfügen müssen.
	    
## <p> <h2> <a id="8.2.2022"> 8.2.2022 </a> </h2>

Wir haben diese Doppelstunde genutzt, um Schaden und Leben in unser Spiel zu integrieren. Wir haben also Stacheln als Hindernisse und ein Lebenssystem hinzugefügt. Bei jedem Schaden verliert man immer ein halbes Herz. Das heißt, wenn man die Stacheln berührt, steigt eine Variable, die den Skin der Herzen je nach Höhe verändert, so dass die Herzen immer geringer werden, wenn man sie berührt. Sobald keine Herzen mehr angezeigt werden, wird das Spiel neu gestartet. Dazu haben wir einen "Fade"-Effekt für den Spieler eingebaut, der das Spiel flüssiger erscheinen lässt. Die Figur wird nicht einfach an den Anfang zurückteleportiert, sondern löst sich langsam auf.
	    
<details>
	<summary>Verlust von Herzen</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163804677-961db120-fac7-47be-9f7c-6ed5c5920754.png)
	
</details>
	    
    
## <p> <h2> <a id="9.2.2022"> 9.2.2022 </a> </h2>
	    
In dieser Unterrichtseinheit haben wir unseren ersten kompletten Level erstellt. Dazu haben wir einen Hintergrund bei Piskel erstellt. Wir haben auch einen Gegner erstellt. Allerdings haben wir die Bewegung für diesen Gegner noch nicht hinzugefügt. Zu diesem Zeitpunkt war dieser Level noch fast komplett ohne Funktionen.

<details>
	<summary>level 1</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163811305-a2edd488-b04e-450e-a1c9-130b631077dc.png)

	
</details>
	    
<details>
	<summary>Piskel Link</summary>
	https://www.piskelapp.com/
</details>

## <p> <h2> <a id="15.2.2022"> 15.2.2022 </a> </h2>
	    
Nur Enis war bei dieser Doppelstunde anwesend. Zum einen nutzte er die Zeit, um weiter an Github zu arbeiten, und zum anderen programmierte er die Bewegung des Gegners. Er hat einen Block erstellt, der die Bewegung des Gegners bestimmt, damit er sich flüssig hin und her bewegen kann. Er begann auch mit der Programmierung der Übergänge in den Levels. Dies erwies sich als große Herausforderung, da der Wechsel von Level zu Level zunächst sehr langsam war. Nach der Stunde recherchierten wir also zu Hause weiter und kamen zu einer groben Lösung, die wir in den nächsten Stunden umsetzen wollten.
<details>
	<summary>Bewegung Gegner 1</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163816488-e5a49ba0-782d-4224-8809-d55a7359ed38.png)
	
</details>	    
	    

## <p> <h2> <a id="16.2.2022"> 16.2.2022 </a> </h2>

Wir nutzen diese Unterrichtseinheit, um den Übergang von Stufe 1 zu Stufe 2 zu programmieren. Dazu haben wir zunächst die grobe Struktur von Level 2 erstellt und als Testversion eingefügt. Nun haben wir die maximale Position bestimmt, die unser Spieler auf der X-Achse einnehmen kann. Nun haben wir einen Befehl geschrieben, der dafür sorgt, dass sich der Hintergrund und damit das Level ändert, sobald der Spieler einen bestimmten Wert auf der X-Achse überschreitet. Natürlich muss der Spieler immer ein Stück nach vorne bewegt werden, sobald sich die Ebene ändert, sonst wird der Spieler direkt wieder in die vorherige Ebene gebracht.
 

<details>
	<summary>Level Wechsel</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163818037-dcdd08f9-8811-4beb-ab6a-f0237b5055e5.png)
	
</details>
	    
## <p> <h2> <a id="22.2.2022"> 22.2.2022 </a> </h2>
	    
Wir haben diese Doppelstunde genutzt, um Level 2 zu erstellen. Level 2 hat im Wesentlichen 2 neue Funktionen. Zum einen einen beweglichen Block, den wir bereits zu Beginn des Projekts programmiert hatten. Zum anderen einen Sprung-Boost. Dieser sorgt dafür, dass unser Spieler bei Berührung extrem hoch springt. Wir haben auch wieder Stacheln hinzugefügt. Der Sprung-Boost funktioniert sehr einfach, denn bei Berührung wird der Spieler einfach in Y-Richtung beschleunigt. Wir haben in diesem Level auch ein Loch eingebaut, über das der Spieler springen muss, sonst verliert er direkt.
	    
<details>
	<summary>Stachel code</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163821265-95cacd39-f3de-42ea-b4ce-8bcc690afc0a.png)
![image](https://user-images.githubusercontent.com/88385822/163824612-8e8cb745-9b21-4469-a823-b9245ea05181.png)
	
</details>

<details>
	<summary>Sprungboost</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163821401-b0f20ba8-3442-4688-b7c8-ba2740fdcbf2.png)
	
</details>
	    
## <p> <h2> <a id="23.2.2022"> 23.2.2022 </a> </h2>
	    
Wir haben diese Stunde genutzt, um einen Plan für unser nächstes Level zu erstellen. Wir kamen auf die Idee, ein wenig Abwechslung einzubauen und eine Shooter-Mechanik hinzuzufügen. Also erstellten wir wieder eine Waffe bei Piskel und überlegten uns die Struktur des Levels.
	    
<details>
	<summary>Waffe</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163832271-8cab5859-addd-4757-b112-552eaf305d5a.png)
	
</details>

## <p> <h2> <a id="1.3.2022"> 1.3.2022 </a> </h2>
	    
Nun machten wir uns an die Arbeit für den 3 Level. Zuerst haben wir unsere alte Mechanik wieder eingebaut und das Grunddesign erstellt. Dann haben wir einen "Spawner" erstellt, d.h. einen Block, aus dem in bestimmten Abständen Feinde auftauchen. Jede Sekunde tauchen zwei Feinde auf und bewegen sich nach links. Um die Performance zu verbessern, haben wir die Klon-Funktion verwendet, da wir so wesentlich weniger Sprites benötigen, da unsere Feinde einfach in bestimmten Abständen geklont werden. Dazu haben wir die Projektile der Waffe programmiert. Sie fliegen immer in die Richtung des Mauszeigers. 
	    
<details>
	<summary>Level 3</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163837663-5ce12a19-69ec-4666-8090-6a1834122395.png)
</details>
	    
<details>
	<summary>Gegner erschaffen</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163837416-9bf2be98-b0d9-402f-95c5-157cf694964c.png)
	
</details>

<details>
	<summary>Projektil richtung</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163837416-9bf2be98-b0d9-402f-95c5-157cf694964c.png)
	
</details>

## <p> <h2> <a id="2.3.2022"> 2.3.2022 </a> </h2>
	    
In dieser Stunde haben wir weiter an Level 3 gearbeitet. Wir haben die Waffe mit einer Abklinkzeit versehen. Außerdem haben wir einen Block erstellt, der das Aufheben der Waffe regelt. Das sorgt dafür, dass das Aufheben der Waffe sehr flüssig und konstant abläuft. Außerdem haben wir weiter auf Github gearbeitet und unsere Projektseite weiter ausgeführt. Wir haben auch einen Lebensbalken für den Spawner programmiert. Dieser sorgt dafür, dass die Treffer der Spawner für den Spieler sichtbar sind und man sehen kann, wie oft man sie noch treffen muss. Sobald die Lebenspunkte der Spawners auf Null gesunken sind, verschwinden die Gegner und der Spawner. Dies waren die Ergebnisse dieser Unterrichtseinheit.
	    
<details>
	<summary>Waffe aufsammeln</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163840574-61caebf1-814b-4892-9a56-e401eb639044.png)
	
</details>
	    
<details>
	<summary>Lebensbalken Spawner</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163844908-f2b706de-f031-4304-b9b5-2035bef4a2bd.png)
	
</details>

<details>
	<summary>Verschwinden des Spawners</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163845073-c4a8ff13-6a67-4c77-946f-95a5143b6d21.png)
	
</details>
	    
## <p> <h2> <a id="8.3.2022"> 8.3.2022 </a> </h2>

*Entfall*

## <p> <h2> <a id="9.3.2022"> 9.3.2022 </a> </h2>
	    
Jetzt haben wir uns langsam dem Endprozess unseres Spiels gewidmet. Dazu haben wir uns überlegt, wie unser endgültiger Level aussehen soll und welche Features wir einbauen wollen. Nachdem wir dies besprochen hatten, begannen wir, den Hintergrund und die Struktur des Levels zu erstellen. Wir wollten das Spiel beenden, indem wir eine Tür öffnen. Dazu müsste man zuerst einen Schlüssel aus einem anderen Level holen. Für die Tür haben wir bei Piskel ein weiteres Design entworfen. Wir begannen auch mit der Programmierung der zweiten Hälfte des letzten Levels.

<details>
	<summary>Finales Level 1/2</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163849580-31d30ec2-f9c6-4a6a-a3f0-3390725e6d55.png)
	
</details>
	    
## <p> <h2> <a id="15.3.2022"> 15.3.2022 </a> </h2>
	    
Diese Doppellektion wurde für das letzte Level weiter verwendet. Hier müssen wir die zweite Hälfte des letzten Levels gestalten. Wir haben uns entschieden, in dieser Hälfte zwei Laserstrahlen einzubauen, die als Hindernisse fungieren. Sie tauchen in regelmäßigen Abständen auf und fügen dem Spieler genau wie die Feinde Schaden zu. Außerdem haben wir eine Grube mit Lava hinzugefügt, die ebenfalls als Hindernis dient. Sie verursacht nicht nur Schaden, sondern führt auch dazu, dass der Spieler alle seine Herzen verliert, wenn er sie berührt. Nun begann eine komplizierte Phase des Projekts, da wir den Übergang zwischen den beiden Ebenen im letzten Level so fließend wie möglich gestalten wollten. Dieser Übergang ist jedoch nicht mehr horizontal, sondern vertikal. Wir haben uns diesem Problem am Ende der Stune gestellt, sind aber nicht sehr weit gekommen und haben die Arbeit auf die nächste Stunde verschoben. 
<details>
	<summary>Finales Level 2/2</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163854630-51d11b27-60bd-43fe-a6c0-943602edeb7e.png)
	
</details>
	    
<details>
	<summary>Laserstrahlen Code</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163854703-a9bc71ab-a33a-4d9f-90f4-e3fe3a1b5630.png)
	
</details>
	    
<details>
	<summary>Lava Code</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163863002-5a70ba7c-9b4c-4d65-865e-30aa184a02af.png)
	
</details>
	    
## <p> <h2> <a id="16.3.2022"> 16.3.2022 </a> </h2>	    
	    
Nun haben wir den Übergang zwischen den beiden Ebenen geschaffen. Dazu haben wir wieder die obere Y-Koordinate bestimmt. Dann haben wir wieder unser altes System angewendet, nur auf der Y-Achse. Es war allerdings recht schwierig, die Bewegung aus der vorherigen Ebene so zu übernehmen, dass sie flüssig aussieht.
 
	    

<details>
	<summary>Übergang Level</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163866087-2e10a9f9-65b7-4981-b182-b47d52d47601.png)
	
</details>
	    
## <p> <h2> <a id="22.3.2022"> 22.3.2022 </a> </h2>

Die Doppelstunde wurde genutzt, um unser Spiel fast fertigzustellen. Wir haben eine Bewegungsanimation für die Lava hinzugefügt. Das lässt das Spiel weniger statisch aussehen. Den Rest der Stunde haben wir auf Github gearbeitet und einige kleine Fehler behoben. Wir haben auch den Schlüssel programmiert, mit dem man die Tür öffnen kann. Wir haben einen Block erstellt, der überprüft, ob der Spieler den Schlüssel einmal berührt hat. Sobald dies geschieht, wird eine Variable erhöht und die Tür kann geöffnet und das Spiel beendet werden. 


<details>
	<summary>Schlüssel Code</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163872144-a78479a8-237e-40c6-99eb-e5df560a2529.png)
	
</details>    

## <p> <h2> <a id="23.3.2022"> 23.3.2022 </a> </h2>

Wir haben diese Stunde genutzt, um Kommentare zu unserem Code hinzuzufügen. Dadurch wird der gesamte Code viel verständlicher und klarer. Es erspart uns auch Arbeit, denn jetzt müssen wir nur noch einen Screenshot einfügen und es erklärt sich von selbst. (Die meisten Screenshots habe ich im Nachhinein eingefügt, damit diese kommentare vorhanden sind.)

## <p> <h2> <a id="29.3.2022"> 29.3.2022 </a> </h2>
In dieser Stunde waren wir beide nicht anwesend. 

## <p> <h2> <a id="30.3.2022"> 30.3.2022 </a> </h2>

*Entfall*


## <p> <h2> <a id="Arbeitsprogress in den Ferien"> Arbeitsprogress in den Ferien </a> </h2>      
      
Während der Ferien wurden einige kleine Verbesserungen vorgenommen. Zum Beispiel haben wir in den Stufen 3 und 4 einen erklärenden Text hinzugefügt. Das hilft der Dynamik des Spiels. Außerdem haben wir die Dynamik unseres Spiels noch weiter erhöht, indem wir die Bewegungen der selbst erstellten Blöcke des Spielers einfacher und damit leichter ausführbar gemacht haben. Im Allgemeinen können wir sagen, dass es uns gelungen ist, unser Spiel auf unseren PCs sehr gut und reibungslos laufen zu lassen, aber leider wissen wir nicht, wie es auf den Schulcomputern aussieht. Eine weitere Neuerung war das Hinzufügen eines Endbildschirms und einer Schaltfläche zum Neustart des Spiels. 
Wir haben den Rest der Ferien auf Github verbracht und unser Projekt fertiggestellt.


<details>
	<summary>Erklärtext Level 3</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163874888-44eb09bb-bd60-4fd6-af08-6dfc2b32150e.png)
	
</details> 


<details>
	<summary>Erklärtext Level 4</summary>
	
![image](https://user-images.githubusercontent.com/88385822/163876034-1cabac73-70c3-4e15-9773-730d6ebb5f61.png)
	
</details>  
